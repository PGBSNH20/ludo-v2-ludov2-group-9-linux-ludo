@page "/Game/{Id:guid}"
@using LinuxLudo.Web.Domain.Models
@inject NavigationManager NavManager; // Used to navigate in the webbrowser to different urls
@using Microsoft.AspNetCore.SignalR.Client
@using LinuxLudo.Core.Models
@using LinuxLudo.Web.Domain.Services
@using LinuxLudo.Web.Services
@inject BrowserService browserService;
@inject IJSRuntime JsRuntime;
@inject Blazored.LocalStorage.ILocalStorageService localStorage;

<AuthorizeView>
    <img @ref="redToken" hidden id="redToken" src="Images/redtoken.png" />
    <img @ref="greenToken" hidden id="greenToken" src="Images/greentoken.png" />
    <img @ref="blueToken" hidden id="blueToken" src="Images/bluetoken.png" />
    <img @ref="yellowToken" hidden id="yellowToken" src="Images/yellowtoken.png" />

    <div class="game-screen" hidden=@(!hasJoinedGame)>
        <h1 class="title-text"><b>@_game.Name</b></h1>
        <div class="game-canvas">
            <BECanvas Width="@_canvasWidth" Height="@_canvasHeight" @ref="_canvas"></BECanvas>
        </div>

        <div class="player-controls @canvasHtmlString">
            <button class="roll-button" @onclick=RollDiceClick>Roll dice</button>
            <button class="bring-token-button" @onclick=BringOutTokenClick>Bring out token</button>

            @functions {
                async Task RollDiceClick() => await RollDice();
                async Task BringOutTokenClick() => await BringOutToken();
            }
        </div>

        <div class="token-selection">
            <h1 class="select-token-text" hidden=@(IsTokenDead('A') && IsTokenDead('B') && IsTokenDead('C') &&
                IsTokenDead('D'))><b>Select your token</b>
                <div class="radio" hidden=@(IsTokenDead('A') && IsTokenDead('B') && IsTokenDead('C') &&
                    IsTokenDead('D'))>
                    @foreach (char tokenSelection in tokenSelections)
                    {
                          <input @onchange="@(() => UpdateTokenSelection(tokenSelection))" hidden=@IsTokenDead(tokenSelection)
                        checked="@(selectedToken.Equals(tokenSelection))" label=@tokenSelection type="radio" id=@($"token-{tokenSelection}") name="token"
                        value=@($"token-{tokenSelection}")>
                    }
                </div>
            </h1>
        </div>
    </div>

    @if (!hasJoinedGame)
    {
        @functions {
            bool GameIsFull => _game.AmountPlaying >= _game.MaxPlayers && _game.MaxPlayers != 0; 
        }

        if(_game.MaxPlayers > 0)
        {
        <div class="game-info">
            <h1 class="game-name">@_game.Name</h1>
            <h2 class="game-details-text" style=@(GameIsFull ? "color: red;" : "")>Slots taken:
                <b>@_game.AmountPlaying</b>/<b>@_game.MaxPlayers</b>
            </h2>
        </div>
        <div class="join-screen" hidden=@(!hasJoinedGame)>
            <button class="game-option-button" disabled=@(GameIsFull) id="play-btn"
            @onclick=JoinGame>@(GameIsFull ? "Game is full" : "Join game")</button>
            <button class="game-option-button" id="browse-btn" @onclick=@(() => NavManager.NavigateTo("/Play"))>Browse
                available games</button>
        </div>
        }else
        {
        <div class="loading-section">
        <h1 class="loading-message">Loading... please wait</h1>
        </div>
        }
    }
</AuthorizeView>

@code
{
    // Misc
    [Parameter]
    public Guid Id { get; set; }
    [CascadingParameter]
    private Task<AuthenticationState> AuthState { get; set; }
    private string userName;
    private AvailableGame _game;
    private const string hubUrl = "https://localhost:5001/gamehub";

    // SignalR
    private HubConnection hubConnection;

    // Canvas
    protected BECanvasComponent _canvas;
    private Canvas2DContext _context;
    private GameRenderer _gameRenderer;
    private GameBoard _board;
    private ElementReference redToken, greenToken, blueToken, yellowToken;
    private int _canvasWidth, _canvasHeight;
    private const int _minWidthResize = 1600;
    private const int _minHeightResize = 720;
    private const float _heightWidthMultiplierIsMobile = 1.2f;
    private string canvasHtmlString => isPlayerTurn ? "" : "hidden";

    // Game
    private GameService _gameService;
    private GameStatus _gameStatus;
    private bool hasJoinedGame = false;
    private string currentStatus = "Waiting for players...";
    private char selectedToken;
    private List<char> tokenSelections => new() {'A','B','C','D'};

    // This is true if it's the client-side player's turn
    private bool isPlayerTurn = true; // TODO SET FROM API

    // When the page has fully loaded
    protected override async Task OnInitializedAsync()
    {
        _game = new();
        var authState = await AuthState;

        // If the user is logged in
        if (authState.User.Identity.IsAuthenticated)
        {
            userName = authState.User.Identity.Name;

            // Fit canvas has to be executed before signalR stuff
            await FitCanvas();

            _board = new GameBoard();

            // Initialize a new GameService to communicate with API
            _gameService = new GameService(@Id, userName);
            var authToken = await localStorage.GetItemAsync<string>("authToken");

            var allGames = await _gameService.FetchAllGames(authToken);
            if(!allGames.Any(game => game.Id == Id.ToString()))
            {
                // Game not found (wrong url entered?)
                Console.WriteLine($"No such game with id: {Id}");
                NavManager.NavigateTo("/Play");
            }else
            {
            _game = allGames.First(game => game.Id == Id.ToString());
            }

            await SetupSignalR();
        }
        else
        {
            NavManager.NavigateTo("/Login");
        }
    }

    protected async Task FitCanvas()
    {
            var windowDim = await browserService.GetDimensions();

            // If the screen is more or less mobile resolution
            if(windowDim.Height >= (windowDim.Width*_heightWidthMultiplierIsMobile))
            {
                _canvasWidth = (windowDim.Width);
            }    
            else if(windowDim.Width >= _minWidthResize && windowDim.Height >= _minHeightResize)
            {
                _canvasWidth = (int)(windowDim.Width  * 0.35);
            }else
            {
                _canvasWidth = (int)(windowDim.Width * 0.7);
            }

            _canvasHeight = (int)(_canvasWidth * 1.15);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _gameStatus = new();
            _context = await _canvas.CreateCanvas2DAsync();

            // Reload UI components on page load (to hide e.g radiobtns)
            StateHasChanged();
            _gameRenderer = new GameRenderer(userName, _canvasWidth, _canvasHeight, redToken, greenToken, blueToken, yellowToken);
        }

        if(hasJoinedGame)
        {
        await RenderGame();
        }
    }

    // This function continously renders the game based on the current fetched data about the game
    protected async Task RenderGame()
    {
        // Creates a canvas
        _context = await _canvas.CreateCanvas2DAsync();

        // Render the latest game details
        await _gameRenderer.RenderGame(_context, _board, _gameStatus, currentStatus, selectedToken);
    }

    protected async Task SetupSignalR()
    {
        hubConnection = new HubConnectionBuilder()
        .WithUrl(hubUrl)
        .Build();


        // Continously listens for received data
        hubConnection.On<string, List<Player>>("ReceiveJoinGame", (userName, players) =>
        {
            _gameStatus.Players = players;
            currentStatus = this.userName == userName ? $"Welcome {userName}!" : $"{userName} has joined the game!";
            StateHasChanged();
        });

        await hubConnection.StartAsync();
    }

    protected async Task RollDice()
    {
        // TODO IMPLEMENT AGAINST SERVER
    }

    protected async Task BringOutToken()
    {
        // TODO IMPLEMENT AGAINST SERVER
    }

    private void UpdateTokenSelection(char token)
    {
        Player player = GetPlayer();
        if (!IsTokenDead(token))
        {
            selectedToken = token;
        }
        else if (player.Tokens.Count > 0)
        {
            if (player.Tokens.Any(t => !t.InBase))
            {
                selectedToken = player.Tokens.FirstOrDefault(token => !token.InBase).IdentifierChar;
            }
            else
            {
                selectedToken = player.Tokens.First().IdentifierChar;
            }
        }
    }

    private bool IsTokenDead(char tokenIdentifier)
    {
        if (_gameStatus != null)
        {
            Player player = GetPlayer();

            // Token is not dead if found in list
            if (!player.Tokens.Any(token => token.IdentifierChar == tokenIdentifier)
            || player.Tokens.Any(token => token.IdentifierChar == tokenIdentifier &&
            token.InBase))
            {
                return true;
            }
        }

        // Token is alive/exists in list
        return false;
    }

    private Player GetPlayer()
    {
        if (_gameStatus != null && _gameStatus.Players.Any(p => p.Name == userName))
        {
            return _gameStatus.Players.First(p => p.Name == userName);
        }
        else
        {
            return new Player("dead", userName + " (SPECTATING)");
        }
    }


    private async Task JoinGame()
    {
        if (_game.AmountPlaying < _game.MaxPlayers)
        {
            await hubConnection.SendAsync("JoinGame", userName, Id);
            hasJoinedGame = true;
            StateHasChanged();
        }
    }
}
