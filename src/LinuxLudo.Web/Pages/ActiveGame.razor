@page "/Game/{Id:int}"
@inject NavigationManager NavManager; // Used to navigate in the webbrowser to different urls

<h1 class="title-text"><b>Game @Id</b></h1>

<AuthorizeView>
    <div class="game-canvas">
        <BECanvas Width="512" Height="576" @ref="_canvas"></BECanvas>
    </div>
</AuthorizeView>

@code
{
    [Parameter]
    public int Id { get; set; }
    [CascadingParameter]
    private Task<AuthenticationState> AuthState { get; set; }
    private string userName;

    // Canvas
    protected BECanvasComponent _canvas;
    private Canvas2DContext _context;
    private GameService _gameService;
    private GameStatus _gameStatus;
    private GameBoard _board;
    private int _tileSize => (int)_canvas.Width / 16;
    private int _tokenSize => (int)_canvas.Width / 18;
    private const int _boardSize = 512;
    private int _topOffset => _tileSize * 2;

    // Game
    private string currentStatus = "Waiting for players...";

    // When the page has fully loaded
    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthState;

        // If the user is logged in
        if (authState.User.Identity.IsAuthenticated)
        {
            userName = authState.User.Identity.Name;
        }
        else
        {
            NavManager.NavigateTo("/Login");
        }

        // Initialize a new GameService to communicate with API
        _gameService = new GameService(@Id);
        _board = new GameBoard();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Creates a canvas
        _context = await _canvas.CreateCanvas2DAsync();

        // Fetches the current gamestatus BEFORE rendering anything
        //_gameStatus = _gameService.GetGameStatus().Result; TODO FETCH FROM API

        // CREATE SIMULATED GAMESTATUS FOR TESTING ONLY!!!!!!!!!!!!!!!!!!!!!
        _gameStatus = new GameStatus();
        _gameStatus.Players = new List<Player>()
{
new Player() {Color = "#800080", Tokens = new List<GameToken>() {
new GameToken() {TilePos= 0},
new GameToken() {TilePos= 0},
new GameToken() {TilePos= 0},
new GameToken() { TilePos = 0 },
}}};

        // Draws a basic canvas background color
        await _context.SetFillStyleAsync("#808080");
        await _context.FillRectAsync(0, 0, _canvas.Width, _canvas.Height);

        DrawGameOverlay();
        DrawBoardLayout();
        DrawPlayers();
    }

    protected async void DrawGameOverlay()
    {
        await _context.SetStrokeStyleAsync("#000000");
        await _context.SetFontAsync("14px serif");

        // Draw a status text, starting at the top-left tile (with a max width of the first row as to not overlap with bases)
        await _context.StrokeTextAsync(currentStatus, (_board.Tiles[0].XPos * _tileSize) + _tileSize, _tileSize + _tileSize / 2,
        _tileSize *
        7);
    }

    protected async void DrawBoardLayout()
    {
        for (int i = 0; i < _board.Tiles.Count; i++)
        {
            GameTile tile = _board.Tiles[i]; String color = "#FFFFFF"; // White color - tile for all tokens,
            switch (tile.TileColor)
            {
                case GameTile.GameColor.Red:
                    color = "#FF0000"; break;
                case GameTile.GameColor.Green: color = "#00FF00"; break;
                case GameTile.GameColor.Blue:
                    color = "#0000FF"; break;
                case GameTile.GameColor.Yellow: color = "#FFFF00"; break;
            } // Draws the actual tile await
            await _context.SetFillStyleAsync(color);
            await _context.FillRectAsync(GetTilePos(i, xPos: true), GetTilePos(i, xPos: false), _tileSize, _tileSize);
        }
    }
    protected async void DrawPlayers()
    {
        if (_gameStatus.Players == null || _gameStatus.Players.Count <= 0)
        {
            currentStatus = "No players in game!";
            return;
        }

        foreach (Player player in _gameStatus.Players)
        {
            // Set the drawing color to match the players tokens await
            await _context.SetFillStyleAsync(player.Color); List<GameToken> playerTokens = player.Tokens;

            // Draws each token, splits up the space if more than one is on the same tile
            for (int i = 0; i < playerTokens.Count; i++)
            {
                int tokensOnSameTile = playerTokens.Count(t => t.TilePos ==
                playerTokens[i].TilePos);
                if (tokensOnSameTile > 1)
                {
                    int index = 0;
                    foreach (GameToken token in playerTokens.Where(t => t.TilePos == playerTokens[i].TilePos))
                    {
                        await _context.FillRectAsync(
                        GetTilePos(token.TilePos, xPos: true) + (_tokenSize / 8) + ((index == 1 || index == 3) ? _tokenSize / 2 : 0),
                        GetTilePos(token.TilePos, xPos: false) + (_tokenSize / 8) + ((index == 1 || index == 2) ? _tokenSize / 2 : 0),
                        _tokenSize / tokensOnSameTile,
                        _tokenSize / tokensOnSameTile);

                        index++;
                    }
                }
                else
                {
                    await _context.FillRectAsync(GetTilePos(playerTokens[i].TilePos, xPos: true) + (_tokenSize / 8),
                    GetTilePos(playerTokens[i].TilePos, xPos:
                    false) + (_tokenSize / 8), _tokenSize, _tokenSize);
                }
            }
        }


    }

    private double GetTilePos(int tileIndex, bool xPos)
    {
        if (xPos)
        {
            return (_board.Tiles[tileIndex].XPos * _tileSize) + _tileSize / 2;
        }

        // Else return yPos
        return ((_board.Tiles[tileIndex].YPos * _tileSize) - _tileSize / 2) +
        _topOffset;
    }
}
